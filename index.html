<!DOCTYPE html>
<html>
<head>
  <title>Illustrative Telephone Chain</title>
  <style>
    body {
      margin: 0;
      background: black;
      font-family: Arial;
      min-height: 100vh;
    }

    /* Container to keep content centered and stacked */
    .page-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      max-width: 850px;
      width: 100%;
      padding: 0 10px;
      box-sizing: border-box;
    }

    /* Header + Buttons container: flex row with space between */
    .header-row {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    h2 {
      color: white;
      margin: 0;
      font-weight: normal;
      text-align: center;
      flex-grow: 1;
    }

    canvas {
      border: 2px solid white;
      background: white;
      cursor: crosshair;
      max-width: 100%;
      height: auto;
    }

    /* Undo container positioned above canvas, left aligned */
    #undoBtn {
      display: flex;
      align-items: center;
      cursor: pointer;
      user-select: none;
      color: white;
      font-size: 16px;
      gap: 6px;
      margin-bottom: 8px;
      align-self: flex-start;
    }
    #undoBtn:hover {
      text-decoration: underline;
    }

    #undoIcon {
      width: 20px;
      height: 20px;
      fill: white;
    }

    /* Mode toggle */
    .mode-toggle {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 20px;
      margin: 20px 0;
    }

    .mode-text {
      font-weight: bold;
      color: white;
      transition: 0.3s;
      opacity: 0.5;
    }
    .mode-text.active {
      opacity: 1;
    }

    #toggle_checkbox { display: none; }

    label {
      position: relative;
      width: 80px;
      height: 40px;
      background: white;
      border-radius: 40px;
      cursor: pointer;
      transition: 0.3s;
    }
    label:after {
      content: "";
      position: absolute;
      top: 4px;
      left: 4px;
      width: 32px;
      height: 32px;
      background: black;
      border-radius: 50%;
      transition: 0.3s;
    }
    #toggle_checkbox:checked + label:after {
      left: 44px;
    }

    /* Buttons */
    .send-button {
      background-color: white;
      color: black;
      border: none;
      padding: 6px 16px;
      font-size: 14px;
      cursor: pointer;
      border-radius: 8px;
      max-width: 140px;
      width: 100%;
    }
    .send-button:hover {
      background-color: #ddd;
    }

    /* ===== TEXT PAGE ===== */
    #textPage {
      display: none; /* hidden initially */
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      width: 100%;
      max-width: 850px;
      padding-top: 80px; /* question slightly lower */
      box-sizing: border-box;
    }

    .text-title {
      color: white;
      font-weight: normal;
      font-size: 28px;
      letter-spacing: 1px;
      text-align: center;
      margin-bottom: 40px;
    }

    .input-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 80vw;
      max-width: 600px;
      gap: 12px;
    }
    .input-container input {
      width: 100%;
      text-align: center;
      font-size: 48px;
      padding: 20px 10px;
      background: black;
      border: none;
      outline: none;
      color: white;
    }
    .input-container input::placeholder {
      color: rgba(255,255,255,0.4);
    }
    .input-container button {
      align-self: flex-end; /* button to right under input */
      white-space: nowrap;
      padding: 10px 28px;
      font-size: 16px;
    }
  </style>
</head>
<body>

  <!-- DRAWING PAGE -->
  <div id="drawPage">
    <div class="page-content">
      <div class="header-row">
        <h2 id="drawTitle">Draw something hehe</h2>
        <button id="sendDraw" class="send-button">Send to Print</button>
      </div>

      <div id="undoBtn" title="Undo last action" tabindex="0" role="button" aria-label="Undo last action">
        <svg id="undoIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M12 5V2L7 7l5 5V7c3.86 0 7 3.14 7 7 0 1.66-.67 3.16-1.76 4.24l1.42 1.42C20.2 18.13 21 15.66 21 13c0-4.97-4.03-9-9-9z"/>
        </svg>
        Undo
      </div>

      <div class="mode-toggle">
        <span class="mode-text left active">Pixel</span>
        <input type="checkbox" id="toggle_checkbox">
        <label for="toggle_checkbox"></label>
        <span class="mode-text right">Pen</span>
      </div>

      <canvas id="canvas" width="800" height="800"></canvas>
    </div>
  </div>

  <!-- TEXT PAGE -->
  <div id="textPage">
    <div class="page-content">
      <h2 class="text-title">What is that?</h2>
      <div class="input-container">
        <input type="text" id="textInput" placeholder="Type here..." autofocus>
        <button id="sendText" class="send-button">Send to Print</button>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const toggleBtn = document.getElementById("toggle_checkbox");
    const leftText = document.querySelector(".mode-text.left");
    const rightText = document.querySelector(".mode-text.right");
    const drawPage = document.getElementById("drawPage");
    const textPage = document.getElementById("textPage");
    const drawTitle = document.getElementById("drawTitle");
    const sendDrawBtn = document.getElementById("sendDraw");
    const sendTextBtn = document.getElementById("sendText");
    const textInput = document.getElementById("textInput");
    const undoBtn = document.getElementById("undoBtn");

    let drawing = false;
    let pixelMode = true;
    let pixelGridSize = 15;
    let canvasSize = 800;

    let penStrokes = [];
    let pixelActions = [];
    let currentStroke = [];

    ctx.lineWidth = 50;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    toggleBtn.addEventListener("change", () => {
      pixelMode = !toggleBtn.checked;
      if (toggleBtn.checked) {
        leftText.classList.remove("active");
        rightText.classList.add("active");
      } else {
        leftText.classList.add("active");
        rightText.classList.remove("active");
      }
    });

    // Drawing events
    canvas.addEventListener("mousedown", (e) => {
      drawing = true;
      const rect = canvas.getBoundingClientRect();
      if (!pixelMode) {
        currentStroke = [];
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        currentStroke.push({x, y});
        ctx.beginPath();
        ctx.moveTo(x, y);
      } else {
        drawPixel(e.clientX - rect.left, e.clientY - rect.top);
      }
    });

    canvas.addEventListener("mouseup", () => {
      if (!drawing) return;
      drawing = false;
      if (!pixelMode && currentStroke.length > 0) penStrokes.push(currentStroke);
    });
    canvas.addEventListener("mouseleave", () => {
      if (!drawing) return;
      drawing = false;
      if (!pixelMode && currentStroke.length > 0) penStrokes.push(currentStroke);
    });
    canvas.addEventListener("mousemove", (e) => {
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      if (pixelMode) drawPixel(x, y);
      else {
        ctx.lineTo(x, y);
        ctx.stroke();
        currentStroke.push({x, y});
      }
    });

    function drawPixel(x, y) {
      const cellSize = canvasSize / pixelGridSize;
      const pixelX = Math.floor(x / cellSize);
      const pixelY = Math.floor(y / cellSize);
      if (!pixelActions.some(p => p.x === pixelX && p.y === pixelY)) {
        pixelActions.push({x: pixelX, y: pixelY, cellSize});
      }
      ctx.fillRect(pixelX * cellSize, pixelY * cellSize, cellSize, cellSize);
    }

    function redrawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (const p of pixelActions) ctx.fillRect(p.x * p.cellSize, p.y * p.cellSize, p.cellSize, p.cellSize);
      ctx.lineWidth = 50;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.strokeStyle = "black";
      for (const stroke of penStrokes) {
        ctx.beginPath();
        if (stroke.length > 0) {
          ctx.moveTo(stroke[0].x, stroke[0].y);
          for (let i = 1; i < stroke.length; i++) ctx.lineTo(stroke[i].x, stroke[i].y);
          ctx.stroke();
        }
      }
    }

    undoBtn.addEventListener("click", () => {
      if (pixelMode && pixelActions.length > 0) pixelActions.pop();
      else if (!pixelMode && penStrokes.length > 0) penStrokes.pop();
      redrawCanvas();
    });

    function sendToPrinter(content) {
      console.log("Send to printer:", content);
    }

    // DRAW → TEXT
    sendDrawBtn.addEventListener("click", () => {
      sendToPrinter(canvas.toDataURL("image/png"));
      penStrokes = [];
      pixelActions = [];
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      drawPage.style.display = "none";
      textPage.style.display = "flex";
      textInput.value = "";
      textInput.focus();
    });

    // TEXT → DRAW
    sendTextBtn.addEventListener("click", () => {
      const inputText = textInput.value || "something";
      sendToPrinter(inputText);
      drawTitle.textContent = `Draw: ${inputText}`;
      textPage.style.display = "none";
      drawPage.style.display = "flex";
    });

    window.addEventListener('beforeunload', (e) => {
      e.preventDefault();
      e.returnValue = 'Warning: Reloading will lose the current transmission chain!';
    });
  </script>
</body>
</html>
